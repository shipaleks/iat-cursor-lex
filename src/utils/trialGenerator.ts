import { ImageData, Trial, Session, WordType } from '../types';
import { shuffle } from './arrayUtils';
// Импортируем новый банк слов
import { AESTHETIC_WORDS } from './wordBank';
// Добавляем импорты Firestore
import { getDocs, collection } from 'firebase/firestore';
import { db } from '../firebase/config'; // Убедимся, что путь правильный
import { getGlobalImageStats } from '../firebase/service'; // Импортируем функцию получения глобальной статистики

// ВАЖНО: Этот список нужно будет наполнить вручную!
// Список наречий, похожих на целевые, но не входящих в них.
// Используется как база для генерации не-слов для уменьшения прайминга.
const EXTERNAL_SIMILAR_ADVERBS: string[] = [
    "ласково", 
    "роскошно", 
    "душевно", 
    "тепло", 
    "плавно", 
    "бодро", 
    "пленительно", 
    "манящее", 
    "уютно", 
    "зловеще", 
    "противно", 
    "жутко", 
    "скверно", 
    "пошло", 
    "низко", 
    "мрачно", 
    "резко", 
    "дико", 
    "плотно", 
    "прочно", 
    "слитно", 
    "стильно", 
    "сбивчиво", 
    "косо", 
    "шатко", 
    "бессвязно", 
    "метко", 
    "чисто", 
    "светло", 
    "смутно", 
    "рыхло", 
    "ярко", 
    "густо", 
    "резво", 
    "тихо", 
    "скудно", 
    "сонно", 
    "нудно", 
    "весело", 
    "горько", 
    "своеобразно", 
    "нестандартно", 
    "банально", 
    "типично", 
    "звонко", 
    "громко", 
    "тонко", 
    "сладко", 
    "гладко", 
    "крепко", 
    "ловко", 
    "быстро", 
    "медленно", 
    "сильно", 
    "слабо", 
    "тяжело", 
    "легко", 
    "высоко", 
    "глубоко", 
    "мелко", 
    "широко", 
    "узко", 
    "долго", 
    "кратко", 
    "рано", 
    "поздно", 
    "часто", 
    "редко", 
    "жидко", 
    "полно", 
    "пусто", 
    "хмуро", 
    "жарко", 
    "холодно", 
    "сухо", 
    "мокро", 
    "твердо", 
    "остро", 
    "тупо", 
    "пышно", 
    "скромно", 
    "круто", 
    "полого", 
    "рельефно", 
    "плоско", 
    "прямо", 
    "близко", 
    "далеко", 
    "внятно", 
    "невнятно", 
    "громоздко", 
    "компактно", 
    "однообразно", 
    "разнообразно", 
    "тесно", 
    "просторно", 
    "пестро", 
    "монотонно", 
    "энергично", 
    "вяловато", 
    "экспрессивно", 
    "сдержанно", 
    "выпукло", 
    "впало", 
    "подробно", 
    "обобщенно", 
    "конкретно", 
    "абстрактно", 
    "академично", 
    "популярно", 
    "задорно", 
    "уныло", 
    "весомо", 
    "легковесно", 
    "солидно", 
    "хлипко", 
    "обильно", 
    "ритмично", 
    "мелодично", 
    "диссонансно", 
    "гармонично", 
    "дисгармонично", 
    "несуразно", 
    "соразмерно", 
    "динамично", 
    "статично", 
    "подвижно", 
    "неподвижно", 
    "текуче", 
    "застойно", 
    "воздушно", 
    "тяжеловесно", 
    "прозрачно", 
    "мутновато", 
    "колоритно", 
    "блекло", 
    "устойчиво", 
    "надежно", 
    "ненадежно", 
    "добротно", 
    "халтурно", 
    "рационально", 
    "нелогично", 
    "последовательно", 
    "непоследовательно", 
    "системно", 
    "бессистемно", 
    "многослойно", 
    "примитивно", 
    "сложно", 
    "линейно", 
    "нелинейно", 
    "спирально", 
    "грустно", 
    "смешно", 
    "скорбно", 
    "буйно", 
    "мирно", 
    "бурно", 
    "нежно", 
    "грубовато", 
    "люто", 
    "мягонько", 
    "робко", 
    "смело", 
    "трусливо", 
    "отважно", 
    "заносчиво", 
    "смирно", 
    "гордо", 
    "униженно", 
    "возвышенно", 
    "мечтательно", 
    "прагматично", 
    "задумчиво", 
    "рассеянно", 
    "внимательно", 
    "небрежно", 
    "аккуратно", 
    "неряшливо", 
    "опрятно", 
    "грязно", 
    "стерильно", 
    "загрязненно", 
    "затхло", 
    "ароматно", 
    "зловонно", 
    "пахуче", 
    "безвкусно", 
    "вкусно", 
    "пресно", 
    "пикантно", 
    "пряно", 
    "знойно", 
    "прохладно", 
    "морозно", 
    "знобко", 
    "палящее", 
    "матово", 
    "глянцево", 
    "шершаво", 
    "ребристо", 
    "волнисто", 
    "зубчато", 
    "заостренно", 
    "закругленно", 
    "угловато", 
    "обтекаемо", 
    "ажурно", 
    "упруго", 
    "вязко", 
    "жестко", 
    "гибко", 
    "ломко", 
    "пластично", 
    "изогнуто", 
    "выпрямленно", 
    "извилисто", 
    "наклонно", 
    "вертикально", 
    "горизонтально", 
    "диагонально", 
    "продольно", 
    "поперечно", 
    "параллельно", 
    "перпендикулярно", 
    "радиально", 
    "концентрично", 
    "упорно", 
    "настойчиво", 
    "уступчиво", 
    "непреклонно", 
    "податливо", 
    "нестойко", 
    "основательно", 
    "интенсивно", 
    "экстенсивно", 
    "распространенно", 
    "многословно", 
    "растянуто", 
    "емко", 
    "разбросанно", 
    "концентрированно", 
    "разбавленно", 
    "насыщенно", 
    "ненасыщенно", 
    "плодотворно", 
    "бесплодно", 
    "продуктивно", 
    "непродуктивно", 
    "результативно", 
    "безрезультатно", 
    "эффективно", 
    "неэффективно", 
    "успешно", 
    "безуспешно", 
    "удачно", 
    "неудачно", 
    "благополучно", 
    "неблагополучно", 
    "позитивно", 
    "негативно", 
    "благотворно", 
    "целесообразно", 
    "нецелесообразно", 
    "обоснованно", 
    "необоснованно", 
    "аргументированно", 
    "бездоказательно", 
    "доказательно", 
    "неопровержимо", 
    "опровержимо", 
    "доступно", 
    "недоступно", 
    "постижимо", 
    "непостижимо", 
    "очевидно", 
    "неочевидно", 
    "открыто", 
    "скрытно", 
    "явственно", 
    "неявственно", 
    "отчетливо", 
    "неотчетливо", 
    "разборчиво", 
    "неразборчиво", 
    "читаемо", 
    "нечитаемо", 
    "членораздельно", 
    "нечленораздельно", 
    "бесцветно", 
    "красочно", 
    "контрастно", 
    "фокусированно", 
    "расфокусированно", 
    "схематично", 
    "скрупулезно", 
    "согласно", 
    "несогласно", 
    "созвучно", 
    "слаженно", 
    "разлаженно", 
    "синхронно", 
    "асинхронно", 
    "аритмично", 
    "немелодично", 
    "благозвучно", 
    "неблагозвучно", 
    "шероховато", 
    "прерывисто", 
    "равномерно", 
    "неравномерно", 
    "многообразно", 
    "многогранно", 
    "односторонне", 
    "всесторонне", 
    "частично", 
    "целиком", 
    "отрывочно", 
    "фрагментарно", 
    "выборочно", 
    "исчерпывающе", 
    "углубленно", 
    "избирательно", 
    "всеобъемлюще", 
    "расплывчато", 
    "определенно", 
    "неопределенно", 
    "приблизительно", 
    "примерно", 
    "буквально", 
    "фигурально", 
    "косвенно", 
    "непосредственно", 
    "опосредованно", 
    "вплотную", 
    "отдаленно", 
    "скученно", 
    "разреженно", 
    "раскидисто", 
    "сгруппированно", 
    "разрозненно", 
    "связно", 
    "несвязно", 
    "раздельно", 
    "сплоченно", 
    "разобщенно", 
    "единообразно", 
    "разнородно", 
    "гомогенно", 
    "гетерогенно", 
    "неоднородно", 
    "целостно", 
    "дробно", 
    "разбито", 
    "монолитно", 
    "составно", 
    "неделимо", 
    "делимо", 
    "дезорганизованно", 
    "упорядоченно", 
    "беспорядочно", 
    "закономерно", 
    "предсказуемо", 
    "непредсказуемо", 
    "ожидаемо", 
    "неожиданно", 
    "запланированно", 
    "спонтанно", 
    "непреднамеренно", 
    "умышленно", 
    "неумышленно", 
    "бессознательно", 
    "намеренно", 
    "ненамеренно", 
    "специально", 
    "продуманно", 
    "непродуманно", 
    "обдуманно", 
    "необдуманно", 
    "взвешенно", 
    "поспешно", 
    "неторопливо", 
    "скоропалительно", 
    "рассудительно", 
    "безрассудно", 
    "осторожно", 
    "неосторожно", 
    "бережно", 
    "прерывисто", 
    "размеренно", 
    "порывисто", 
    "степенно", 
    "отрывисто", 
    "скачкообразно", 
    "вариативно", 
    "постоянно", 
    "переменчиво", 
    "симметрично", 
    "асимметрично", 
    "несоразмерно", 
    "несбалансированно", 
    "неуравновешенно", 
    "консонантно", 
    "диссонантно", 
    "какофонично", 
    "разнозвучно", 
    "полихромно", 
    "многоцветно", 
    "нюансированно", 
    "внезапно", 
    "постепенно", 
    "единовременно", 
    "поэтапно", 
    "разом", 
    "моментально", 
    "длительно", 
    "протяженно", 
    "кратковременно", 
    "долговременно", 
    "сиюминутно", 
    "перспективно", 
    "временно", 
    "эпизодически", 
    "систематически", 
    "периодически", 
    "нерегулярно", 
    "спорадически", 
    "ациклично", 
    "внесезонно", 
    "ежедневно", 
    "еженедельно", 
    "ежемесячно", 
    "ежегодно", 
    "ежесекундно", 
    "ежеминутно", 
    "ежечасно", 
    "эпизодично", 
    "алогично", 
    "иррационально", 
    "расчетливо", 
    "импульсивно", 
    "произвольно", 
    "непроизвольно", 
    "контролируемо", 
    "неконтролируемо", 
    "управляемо", 
    "неуправляемо", 
    "неслучайно", 
    "стихийно", 
    "нестрого", 
    "снисходительно", 
    "нетребовательно", 
    "категорично", 
    "некатегорично", 
    "безапелляционно", 
    "компромиссно", 
    "бескомпромиссно", 
    "предельно", 
    "беспредельно", 
    "миниатюрно", 
    "гигантски", 
    "крошечно", 
    "грандиозно", 
    "малозаметно", 
    "впечатляюще", 
    "неприметно", 
    "осязаемо", 
    "неосязаемо", 
    "нереально", 
    "действительно", 
    "мнимо", 
    "фактически", 
    "теоретически", 
    "практически", 
    "гипотетически", 
    "достоверно", 
    "недостоверно", 
    "подлинно", 
    "поддельно", 
    "истинно", 
    "правдиво", 
    "обманчиво", 
    "откровенно", 
    "лукаво", 
    "прямодушно", 
    "хитро", 
    "искренне", 
    "лицемерно", 
    "честно", 
    "нечестно", 
    "тайно", 
    "публично", 
    "приватно", 
    "гласно", 
    "негласно", 
    "демонстративно", 
    "показно", 
    "вызывающе", 
    "ненавязчиво", 
    "навязчиво", 
    "деликатно", 
    "бесцеремонно", 
    "тактично", 
    "бестактно", 
    "учтиво", 
    "любезно", 
    "нелюбезно", 
    "приветливо", 
    "неприветливо", 
    "дружелюбно", 
    "недружелюбно", 
    "радушно", 
    "нерадушно", 
    "гостеприимно", 
    "негостеприимно", 
    "замкнуто", 
    "общительно", 
    "необщительно", 
    "разговорчиво", 
    "молчаливо", 
    "словоохотливо", 
    "немногословно", 
    "красноречиво", 
    "косноязычно", 
    "витиевато", 
    "прямолинейно", 
    "пространно", 
    "образно", 
    "безобразно", 
    "метафорично", 
    "аллегорично", 
    "реалистично", 
    "символично", 
    "натуралистично", 
    "воздушно", 
    "величаво", 
    "плаксиво", 
    "вдумчиво", 
    "яростно", 
    "мудрено", 
    "затейливо", 
    "дивно", 
    "кудряво", 
    "сумрачно", 
    "певуче", 
    "зябко", 
    "томно", 
    "вычурно", 
    "заливисто", 
    "выразимо", 
    "звучно", 
    "лучисто", 
    "проникновенно", 
    "пылко", 
    "возмутительно", 
    "карикатурно", 
    "слезно", 
    "вольготно", 
    "призрачно", 
    "неистово", 
    "мятежно", 
    "трепетно", 
    "знаменательно", 
    "значительно", 
    "маловажно", 
    "убедительно", 
    "неубедительно", 
    "легковерно", 
    "доверчиво", 
    "скептично", 
    "поверхностно", 
    "стилизованно", 
    "подражательно", 
    "традиционно", 
    "классично", 
    "авангардно", 
    "новаторски", 
    "самобытно", 
    "обособленно", 
    "стандартизированно", 
    "унифицированно", 
    "клишированно", 
    "заезженно", 
    "истасканно", 
    "испитано", 
    "благородно", 
    "униженно", 
    "возвышенно", 
    "царственно", 
    "величественно", 
    "расточительно", 
    "экономно", 
    "бережливо", 
    "щедро", 
    "скупо", 
    "накладно", 
    "марко", 
    "затратно", 
    "малозатратно", 
    "безотходно", 
    "расточно", 
    "неэкономно", 
    "фатально", 
    "неотвратимо", 
    "непременно", 
    "неизбежно", 
    "неизменно", 
    "случайно", 
    "произвольно", 
    "обязательно", 
    "необязательно", 
    "целенаправленно", 
    "бесцельно", 
    "целеустремленно", 
    "стройно", 
    "нескладно", 
    "складно", 
    "созидательно", 
    "разрушительно", 
    "плодотворно", 
    "творчески", 
    "деструктивно", 
    "безопасно", 
    "опасно", 
    "рискованно", 
    "безрисково", 
    "подконтрольно", 
    "регулируемо", 
    "подчиненно", 
    "самостоятельно", 
    "автономно", 
    "зависимо", 
    "независимо", 
    "взаимосвязанно", 
    "изолированно", 
    "самодостаточно", 
    "интегрированно", 
    "сплоченно", 
    "разрозненно", 
    "слитно", 
    "раздельно", 
    "разобщенно", 
    "контактно", 
    "идентично", 
    "разграниченно", 
    "объединительно", 
    "централизованно", 
    "скученно", 
    "скопом", 
    "кучно", 
    "гуртом", 
    "табунно", 
    "стайно", 
    "стадно", 
    "массово", 
    "индивидуально", 
    "персонально", 
    "лично", 
    "коллективно", 
    "совместно", 
    "солидарно", 
    "раздробленно", 
    "фрагментарно", 
    "дискретно", 
    "непрерывно", 
    "континуально", 
    "беспрерывно", 
    "частично", 
    "выборочно", 
    "сплошно", 
    "избирательно", 
    "полностью", 
    "фрагментами", 
    "отрывисто", 
    "планомерно", 
    "методично", 
    "спонтанно", 
    "экспромтно", 
    "импульсивно", 
    "реактивно", 
    "проактивно", 
    "активно", 
    "пассивно", 
    "инициативно", 
    "деятельно", 
    "бездеятельно", 
    "подвижно", 
    "малоподвижно", 
    "неподвижно", 
    "стационарно", 
    "мобильно", 
    "перемещаемо", 
    "закрепленно", 
    "фиксированно", 
    "изменчиво", 
    "неизменно", 
    "стабильно", 
    "нестабильно", 
    "волатильно", 
    "постоянно", 
    "непостоянно", 
    "устойчиво", 
    "неустойчиво", 
    "уравновешенно", 
    "неуравновешенно", 
    "гармонично", 
    "дисгармонично", 
    "адекватно", 
    "неадекватно", 
    "соответственно", 
    "несоответственно", 
    "сообразно", 
    "несообразно", 
    "органично", 
    "неорганично", 
    "вписанно", 
    "контрастно", 
    "согласованно", 
    "несогласованно", 
    "совместимо", 
    "несовместимо", 
    "сочетаемо", 
    "несочетаемо", 
    "взаимодополняюще", 
    "антагонистично", 
    "синергетично", 
    "конкурентно", 
    "соревновательно", 
    "конфликтно", 
    "полемично", 
    "мирно", 
    "враждебно", 
    "недружественно", 
    "агрессивно", 
    "неагрессивно", 
    "благожелательно", 
    "неблагожелательно", 
    "доброжелательно", 
    "дружественно", 
    "союзно", 
    "бессоюзно", 
    "вражески", 
    "нейтрально", 
    "беспристрастно", 
    "пристрастно", 
    "объективно", 
    "субъективно", 
    "отстраненно", 
    "вовлеченно", 
    "заинтересованно", 
    "незаинтересованно", 
    "безразлично", 
    "небезразлично", 
    "равнодушно", 
    "неравнодушно", 
    "эмоционально", 
    "неэмоционально", 
    "чувственно", 
    "рационально", 
    "иррационально", 
    "логично", 
    "интуитивно", 
    "инстинктивно", 
    "осознанно", 
    "неосознанно", 
    "произвольно", 
    "непроизвольно", 
    "намеренно", 
    "ненамеренно", 
    "случайно", 
    "неслучайно", 
    "специально", 
    "неспециально", 
    "нарочно", 
    "ненарочно", 
    "преднамеренно", 
    "непреднамеренно", 
    "умышленно", 
    "неумышленно", 
    "целенаправленно", 
    "сознательно", 
    "бессознательно", 
    "осмысленно", 
    "неосмысленно", 
    "вдумчиво", 
    "невдумчиво", 
    "задумчиво", 
    "размышляюще", 
    "аналитично", 
    "критично", 
    "оценочно", 
    "беспристрастно", 
    "пристрастно", 
    "позитивно", 
    "негативно", 
    "нейтрально", 
    "амбивалентно", 
    "неоднозначно", 
    "однозначно", 
    "альтернативно", 
    "безальтернативно", 
    "вариативно", 
    "многовариантно", 
    "одновариантно", 
    "разнонаправленно", 
    "однонаправленно", 
    "комплексно", 
    "комбинаторно", 
    "составно", 
    "композиционно", 
    "конструктивно", 
    "деструктивно", 
    "структурированно", 
    "неструктурированно", 
    "смешанно", 
    "несмешанно", 
    "гибридно", 
    "комбинированно", 
    "смешиваемо", 
    "соединяемо", 
    "связываемо", 
    "сцепляемо", 
    "расчленяемо", 
    "делимо", 
    "неделимо", 
    "разбираемо", 
    "соединяемо", 
    "растворимо", 
    "нерастворимо", 
    "разрешимо", 
    "неразрешимо", 
    "решаемо", 
    "нерешаемо", 
    "загадочно", 
    "незагадочно", 
    "мистично", 
    "немистично", 
    "таинственно", 
    "нетаинственно", 
    "секретно", 
    "несекретно", 
    "конфиденциально", 
    "неконфиденциально", 
    "интимно", 
    "неинтимно", 
    "лично", 
    "публично", 
    "общественно", 
    "частно", 
    "приватно", 
    "корпоративно", 
    "изолированно", 
    "отчужденно", 
    "допускающе", 
    "запретительно", 
    "разрешительно", 
    "запрещающе", 
    "разрешающе", 
    "дозволяюще", 
    "позволительно", 
    "непозволительно", 
    "санкционированно", 
    "законно", 
    "незаконно", 
    "правомерно", 
    "неправомерно", 
    "легально", 
    "нелегально", 
    "криминально", 
    "некриминально", 
    "преступно", 
    "непреступно", 
    "легитимно", 
    "нелегитимно", 
    "уполномоченно", 
    "авторизованно", 
    "делегированно", 
    "доверенно", 
    "доверительно", 
    "недоверительно", 
    "конфиденциально", 
    "секретно", 
    "публично", 
    "огласно", 
    "неогласно", 
    "открыто", 
    "закрыто", 
    "прозрачно", 
    "непрозрачно", 
    "ясно", 
    "неясно", 
    "очевидно", 
    "неочевидно", 
    "видимо", 
    "невидимо", 
    "зримо", 
    "незримо", 
    "ощутимо", 
    "неощутимо", 
    "чувствуемо", 
    "нечувствуемо", 
    "осязаемо", 
    "неосязаемо", 
    "материально", 
    "нематериально", 
    "физично", 
    "нефизично", 
    "телесно", 
    "нетелесно", 
    "бестелесно", 
    "одухотворенно", 
    "неодухотворенно", 
    "сакрально", 
    "профанно", 
    "ритуально", 
    "обрядово", 
    "нежданно", 
    "негаданно", 
    "чудотворно", 
    "нечудотворно", 
    "чудесно", 
    "чудно", 
    "странно", 
    "необыкновенно", 
    "обыкновенно", 
    "заурядно", 
    "незаурядно", 
    "исключительно", 
    "неисключительно", 
    "особенно", 
    "неособенно", 
    "специфично", 
    "неспецифично", 
    "своеобразно", 
    "несвоеобразно", 
    "типично", 
    "нетипично", 
    "характерно", 
    "нехарактерно", 
    "выделяющееся", 
    "фоново", 
    "выраженно", 
    "невыраженно", 
    "акцентированно", 
    "подчеркнуто", 
    "ударно", 
    "безударно", 
    "ритмично", 
    "неритмично", 
    "метрично", 
    "музыкально", 
    "немузыкально", 
    "гармонично", 
    "негармонично", 
    "согласованно", 
    "несогласованно", 
    "синхронно", 
    "несинхронно", 
    "одновременно", 
    "неодновременно", 
    "скоординированно", 
    "координированно", 
    "целенаправленно", 
    "нецеленаправленно", 
    "целесообразно", 
    "нецелесообразно", 
    "целеустремленно", 
    "мотивированно", 
    "немотивированно", 
    "заинтересованно", 
    "вдохновенно", 
    "воодушевленно", 
    "креативно", 
    "некреативно", 
    "творчески", 
    "свободно", 
    "несвободно", 
    "раскрепощенно", 
    "непринужденно", 
    "принужденно", 
    "спонтанно", 
    "раскованно", 
    "непосредственно", 
    "открыто", 
    "закрыто", 
    "доверчиво", 
    "недоверчиво", 
    "доверительно", 
    "простодушно", 
    "просто", 
    "непросто", 
    "легко", 
    "нелегко", 
    "трудно", 
    "нетрудно", 
    "сложно", 
    "несложно", 
    "комфортно", 
    "некомфортно", 
    "уютно", 
    "неуютно", 
    "утонченно", 
    "выхоленно", 
    "изысканно", 
    "неизысканно", 
    "элегантно", 
    "изнеженно", 
    "грубо", 
    "негрубо", 
    "массивно", 
    "медово", 
    "молочно", 
    "сливочно", 
    "бархатно", 
    "гладко", 
    "шершаво", 
    "грубо", 
    "мягко", 
    "жестко", 
    "нежно", 
    "невесомо", 
    "легко", 
    "трудно", 
    "воздушно", 
    "монументально", 
    "неединообразно", 
    "единообразно", 
    "фактурно", 
    "мажорно", 
    "минорно", 
    "ухабисто", 
    "болотисто", 
    "песчано", 
    "пустынно", 
    "лесисто", 
    "горно", 
    "низинно", 
    "равнинно", 
    "равномерно", 
    "неравномерно", 
    "стихийно", 
    "урегулированно", 
    "скоординированно", 
    "согласованно", 
    "синхронизированно", 
    "организованно", 
    "слаженно", 
    "ритмично", 
    "аритмично", 
    "циклично", 
    "периодично", 
    "систематично", 
    "волнообразно", 
    "прямолинейно", 
    "криволинейно", 
    "ступенчато", 
    "многогранно", 
    "многоугольно", 
    "изогнуто", 
    "ломано", 
    "зубчато", 
    "волнисто", 
    "ребристо", 
    "бороздчато", 
    "гребенчато", 
    "извилисто", 
    "щетинисто", 
    "ворсисто", 
    "мохнато", 
    "опушенно", 
    "пернато", 
    "чешуйчато", 
    "шиповато", 
    "ланцетовидно", 
    "ромбовидно", 
    "квадратно", 
    "прямоугольно", 
    "многоугольно", 
    "сферически", 
    "вогнуто", 
    "выпукло", 
    "угловато", 
    "обтекаемо", 
    "сглаженно", 
    "пристойно", 
    "непристойно", 
    "адекватно", 
    "неадекватно", 
    "подходяще", 
    "бесстрастно", 
    "страстно", 
    "неубедительно", 
    "убедительно", 
    "абстрактно", 
    "конкретно", 
    "предметно", 
    "беспредметно", 
    "буквально", 
    "аллегорично", 
    "метафорично", 
    "конкретно", 
    "специфично", 
    "детализированно", 
    "подробно", 
    "основательно", 
    "поверхностно", 
    "глубоко"
];

// Создаем Set из внешнего списка для быстрой проверки (если он не пуст)
const EXTERNAL_ADVERBS_SET = new Set(EXTERNAL_SIMILAR_ADVERBS.map(w => w.toLowerCase()));

// Объединяем основной банк и внешний для общей проверки на реальные слова
const ALL_REAL_WORDS_FOR_CHECK = new Set([
    ...AESTHETIC_WORDS.map(w => w.word.toLowerCase()),
    ...EXTERNAL_SIMILAR_ADVERBS.map(w => w.toLowerCase())
]);

const DICTIONARY_PATH = '/data/exp2_samples.csv';
let modelDictionaryCache: { [key: string]: string } | null = null;

// Функция загрузки словаря моделей (обновлена для лучшей обработки CSV)
export async function loadModelDictionary(): Promise<{ [key: string]: string }> {
  // Если словарь уже в кеше, возвращаем его
  if (modelDictionaryCache) {
    console.log('Returning cached model dictionary.');
    return modelDictionaryCache;
  }

  try {
    console.log('Loading model dictionary from:', DICTIONARY_PATH);
    const response = await fetch(DICTIONARY_PATH);
    if (!response.ok) {
      console.error(`Failed to load ${DICTIONARY_PATH}:`, response.status, response.statusText);
      throw new Error(`Failed to load ${DICTIONARY_PATH}`);
    }
    
    const text = await response.text();
    console.log('Dictionary content received (first 100 chars):', text.slice(0, 100) + '...');
    
    // Усовершенствованный парсер CSV, работающий с кавычками и переносами строк внутри полей
    const parseCSV = (text: string): string[][] => {
      const rows: string[][] = [];
      let row: string[] = [];
      let inQuotes = false;
      let currentValue = '';
      
      for (let i = 0; i < text.length; i++) {
        const char = text[i];
        
        if (char === '"') {
          // Проверяем на экранированную кавычку (двойная кавычка внутри поля)
          if (i + 1 < text.length && text[i + 1] === '"') {
            currentValue += '"';
            i++; // Пропускаем вторую кавычку
          } else {
            // Переключаем состояние кавычек
            inQuotes = !inQuotes;
          }
        } else if (char === ',' && !inQuotes) {
          // Запятая вне кавычек - конец ячейки
          row.push(currentValue);
          currentValue = '';
        } else if (char === '\n' && !inQuotes) {
          // Новая строка вне кавычек - конец строки
          row.push(currentValue);
          rows.push(row);
          row = [];
          currentValue = '';
        } else if (char === '\r') {
          // Игнорируем возврат каретки
          continue;
        } else {
          // Добавляем символ в текущее значение
          currentValue += char;
        }
      }
      
      // Добавляем последнюю ячейку и строку, если они есть
      if (currentValue !== '' || row.length > 0) {
        row.push(currentValue);
        rows.push(row);
      }
      
      return rows;
    };
    
    const rows = parseCSV(text);
    
    // Получаем индексы нужных колонок из заголовка
    const headers = rows[0];
    const fileNameIndex = headers.findIndex(h => h.trim() === 'file_name');
    const modelNameIndex = headers.findIndex(h => h.trim() === 'model_name');
    
    if (fileNameIndex === -1 || modelNameIndex === -1) {
      console.error('Required columns not found in the CSV file:', headers);
      throw new Error('Invalid CSV format: missing required columns');
    }
    
    // Пропускаем заголовок
    const data = rows.slice(1); 
    
    // Строим словарь моделей
    const dict = data.reduce((acc, row) => {
      if (row.length <= Math.max(fileNameIndex, modelNameIndex)) {
        console.warn('Skipping incomplete row in dictionary:', row);
        return acc;
      }
      
      const fileName = row[fileNameIndex]?.trim(); // file_name
      const model = row[modelNameIndex]?.trim();   // model_name
      
      if (fileName && model) {
        acc[fileName] = model;
      } else {
        // Логируем, если строка некорректна, но не прерываем процесс
        console.warn('Skipping invalid row in dictionary:', row);
      }
      return acc;
    }, {} as { [key: string]: string });
    
    console.log('Dictionary loaded successfully. Entries:', Object.keys(dict).length);
    
    // Для отладки: проверим конкретные файлы из CSV
    const filesToDebug = ['17.png', '19.png', '32.png'];
    filesToDebug.forEach(file => {
      if (dict[file]) {
        console.log(`File ${file} has model: ${dict[file]}`);
      } else {
        console.warn(`File ${file} NOT FOUND in dictionary!`);
      }
    });
    
    // Сохраняем в кеш
    modelDictionaryCache = dict; 
    return dict;
  } catch (error) {
    console.error('Error loading model dictionary:', error);
    // Возвращаем пустой объект в случае ошибки, чтобы не блокировать остальную логику
    return {}; 
  }
}

// Загружаем данные из images напрямую без промежуточного словаря
let IMAGES: ImageData[] = [];

// Улучшенная функция для загрузки изображений напрямую из папки
export async function loadImages(): Promise<ImageData[]> {
  // Если изображения уже загружены, возвращаем их
  if (IMAGES.length > 0) {
    return IMAGES;
  }
  
  // Загружаем словарь моделей перед поиском изображений
  const modelDictionary = await loadModelDictionary();
  console.log(`Loaded model dictionary with ${Object.keys(modelDictionary).length} entries`);

  try {
    const imagesPath = '/images';
    console.log('Loading images metadata from', imagesPath);
    
    const foundImages: ImageData[] = [];
    
    // Улучшенный метод: создаем метаданные изображений без их предварительной загрузки
    // Проверяем файлы от 0.png до 599.png (или сколько есть в CSV)
    const maxIndex = 600; // Ограничиваем до 600 файлов для оптимизации
    let missingModelCount = 0;
    
    for (let i = 0; i < maxIndex; i++) {
      const fileName = `${i}.png`;
      
      // Определяем модель из словаря (без загрузки изображения)
      let model = modelDictionary[fileName];
      
      if (!model) {
        missingModelCount++;
        if (missingModelCount <= 10) {
          console.warn(`Model not found in dictionary for image: ${fileName}`);
        }
        model = 'unknown_model'; // Устанавливаем значение по умолчанию
      }
      
      // Добавляем метаданные без предварительной загрузки изображения
      foundImages.push({
        id: String(i),
        fileName: fileName,
        url: `${imagesPath}/${fileName}`,
        model: model,
        target: 'not_used',
        antonym: 'not_used'
      });
    }
    
    if (foundImages.length === 0) {
      throw new Error('No images metadata could be created');
    }
    
    if (missingModelCount > 0) {
      console.warn(`Total files without model info: ${missingModelCount}`);
    }
    
    IMAGES = foundImages;
    
    // Анализируем информацию о моделях
    const modelsCount: {[key: string]: number} = {};
    IMAGES.forEach(img => {
      modelsCount[img.model] = (modelsCount[img.model] || 0) + 1;
    });
    
    console.log("Models distribution:");
    Object.entries(modelsCount).forEach(([model, count]) => {
      console.log(`  ${model}: ${count} images`);
    });
    
    console.log(`Successfully loaded metadata for ${IMAGES.length} images`);
    return IMAGES;
  } catch (error) {
    console.error('Error loading images metadata:', error);
    throw new Error(`Failed to load images metadata: ${error}`);
  }
}

// Экспортируем массив изображений
export { IMAGES };

// Типичные окончания для разных типов слов
const WORD_ENDINGS = {
  nouns: {
    abstract: ['ость', 'ота', 'ство', 'ание', 'ение'],
    other: ['ак', 'ик', 'ец', 'от', 'ар', 'ир', 'ор', 'ун', 'ыш', 'ач']
  },
  adverbs: ['но', 'во']
};

// Обновляем список гласных и согласных для большей точности
const VOWELS_RU = 'аеиоуыэюя';
const CONSONANTS_RU = 'бвгджзйклмнпрстфхцчшщ';
const ALL_LETTERS_RU = VOWELS_RU + CONSONANTS_RU;

// Множества для быстрой проверки
const VOWELS_SET = new Set(VOWELS_RU.split(''));
const CONSONANTS_SET = new Set(CONSONANTS_RU.split(''));

// Запрещенные сочетания букв (расширяем для улучшения качества)
const FORBIDDEN_CLUSTERS = [
    // ... существующие кластеры ...
    'цщ', 'шц', 'щш', 'чщ', 'щч', 'сщ', 'зщ', 'жц', 'цж', 
    // Подряд звонкая+глухая или наоборот (упрощенно)
    'гк', 'кг', 'бп', 'пб', 'дт', 'тд', 'жш', 'шж', 'зс', 'сз', 
    // Й перед/после не-гласных или в нетипичных местах
    'йь', 'йъ', 'йб', 'йв', 'йг', 'йд', 'йж', 'йз', 'йк', 'йл', 'йм', 'йн', 'йп', 'йр', 'йс', 'йт', 'йф', 'йх', 'йц', 'йч', 'йш', 'йщ',
    'бй', 'вй', 'гй', 'дй', 'жй', 'зй', 'кй', 'лй', 'мй', 'нй', 'пй', 'рй', 'сй', 'тй', 'фй', 'хй', 'цй', 'чй', 'шй', 'щй',
    // Редкие сочетания с гласными и ь/ъ
    'ыы', 'эы', 'иы', 'уы', 'юы', 'яы',
    'ъь', 'ьъ', 'ъ[аоуыэюя]', '[аоуыэюя]ъ', // Ъ обычно после согласных и перед е, ё, ю, я
    'ь[аоуыэюя]', // Ь обычно после согласных
    // Слишком много согласных (проверяется отдельно, но можно добавить явные случаи)
    'бгд', 'птк', 'жзд', 'шст', // Труднопроизносимые
    'йь', 'йъ', 'ьй', 'ъй', 'ъь', 'ьъ', 
    'ыы', 'эы', 'яы', 'юы', 'иы', // Редкости
    'цщ', 'щц', // Очень редкие
    // Добавляем нетипичные сдвоенные согласные:
    'чч', 'шш', 'жж', 'щщ' 
];

// Разрешенные начальные двухсогласные сочетания (для ужесточения проверки)
// Источник: Комбинация знаний и примеров, может требовать доработки
const ALLOWED_INITIAL_CONSONANT_CLUSTERS = new Set([
    'бл', 'бр', 'вз', 'вл', 'вн', 'вр', 'вс', 'вш', 'гл', 'гн', 'гр', 
    'дв', 'др', 'жг', 'жд', 'жм', 'жн', 'зв', 'зд', 'зл', 'зм', 'зн', 
    'кл', 'кн', 'кр', 'кс', 'кт', 'мг', 'мл', 'мн', 'мр', 'мч', 'мш', 
    'нр', 'нз', 'пл', 'пр', 'пс', 'пт', 'рж', 'рз', 'рт', 'св', 'сг', 
    /*'зд',*/ 'зг', 'ск', 'сл', 'см', 'сн', 'сп', 'ст', 'сф', 'сх', 'сц', // Дубликат 'зд' убран
    'тв', 'тк', 'тл', 'тм', 'тн', 'тр', 'тщ', 'хв', 'хл', 'хм', 'хр', 
    'цв', 'цм', 'цн', 'чв', 'чк', 'чл', 'чм', 'шв', 'шк', 'шл', 'шм', 
    'шн', 'шп', 'шт', 'щн' 
]);

// Банк реальных слов для проверки при мутации (теперь используем объединенный)
const REAL_WORDS_SET = ALL_REAL_WORDS_FOR_CHECK;

// Функция для получения случайного элемента массива
function getRandomElement<T>(arr: T[]): T {
  if (!arr || arr.length === 0) {
      throw new Error("Cannot get random element from empty array");
  }
  return arr[Math.floor(Math.random() * arr.length)];
}

// Функция проверки благозвучия (v2 - более строгая)
function isPhonotacticallyPlausible(word: string): boolean {
  const lowerWord = word.toLowerCase();
  const len = lowerWord.length;

  // 0. Базовая проверка на символы и длину
  if (/[^а-яё]/i.test(word)) return false; // Только русские буквы
  if (len < 4 || len > 14) return false;

  // 1. Проверка гласных
  if (hasConsecutiveVowels(lowerWord, 2)) return false; // Не более 2 гласных подряд
  // Доп. проверка на нежелательные пары гласных
  if (/[ыэи][ы]/.test(lowerWord) || /[э][иаоуэюя]/.test(lowerWord)) return false; 

  // 2. Проверка согласных
  if (hasConsecutiveConsonants(lowerWord, 4)) return false; // Не более 3 согласных подряд

  // 3. Проверка на запрещенные кластеры ВНУТРИ слова
  for (const cluster of FORBIDDEN_CLUSTERS) {
    if (lowerWord.includes(cluster)) {
      // console.log(`Rejected by cluster: ${cluster} in ${word}`);
  return false;
    }
  }

  // 4. Проверка НАЧАЛА слова
  if (/[ъь]/.test(lowerWord[0])) return false; // Не начинается с ь/ъ
  // --- ИСПРАВЛЕННАЯ ПРОВЕРКА НА 3 СОГЛАСНЫХ В НАЧАЛЕ ---
  if (len >= 3 && 
      CONSONANTS_SET.has(lowerWord[0]) && 
      CONSONANTS_SET.has(lowerWord[1]) && 
      CONSONANTS_SET.has(lowerWord[2])) {
      // console.log(`Rejected: Starts with 3 consonants (${lowerWord.substring(0,3)})`);
      return false; // Запрещаем 3 согласных в начале
  }
  // --- КОНЕЦ ИСПРАВЛЕНИЯ ---
  // Проверка на разрешенные ДВЕ начальные согласные (если их две)
  if (len >= 2 && 
      CONSONANTS_SET.has(lowerWord[0]) && 
      CONSONANTS_SET.has(lowerWord[1])) {
          const initial_cluster = lowerWord.substring(0, 2);
          if (!ALLOWED_INITIAL_CONSONANT_CLUSTERS.has(initial_cluster)) {
               // console.log(`Rejected: Disallowed initial 2-consonant cluster (${initial_cluster})`);
              return false;
          }
  }
  // Проверка на нежелательные первые буквы
  if (/[цщ]/.test(lowerWord[0])) return false; // Не начинается с ц/щ (редко для наречий)

  // 5. Проверка КОНЦА слова
  if (/[йъ]/.test(lowerWord[len - 1])) return false; // Не кончается на й/ъ
  if (hasConsecutiveConsonants(lowerWord.substring(len - 2), 2) && !/[лнрм]$/.test(lowerWord)) {
    // Если кончается на 2 согласные, последняя должна быть сонорной (упрощенно)
    // return false; // Пока отключим, может быть слишком строгим для не-слов
  }
  if (/[чщшжц]$/.test(lowerWord) && lowerWord.slice(-2) !== 'ич'){
      // Не кончается на шипящие/ц (кроме суффикса -ичн(о/в))
      // return false; // Тоже пока отключим
  }

  // 6. Проверка Ь/Ъ
  for (let i = 0; i < len; i++) {
    const char = lowerWord[i];
    const prevChar = lowerWord[i - 1] || '';
    const nextChar = lowerWord[i + 1] || '';

    if (char === 'ъ') {
      // Ъ только после согласных и перед [еёюя]
      if (!CONSONANTS_SET.has(prevChar) || !/[еёюя]/.test(nextChar)) return false; 
    }
    if (char === 'ь') {
      // Ь только после согласных, не перед ь/ъ/й
      if (!CONSONANTS_SET.has(prevChar) || /[ьъй]/.test(nextChar)) return false;
      // Ь не перед гласными, кроме [еёиюя] (и то не всегда)
      if (VOWELS_SET.has(nextChar) && !/[еёиюя]/.test(nextChar)) return false;
    }
  }

  return true;
}

// Переписываем старые функции проверки с учетом новых констант
function hasConsecutiveVowels(word: string, maxConsecutive: number = 1): boolean {
  let consecutiveCount = 0;
  for (let i = 0; i < word.length; i++) {
    if (VOWELS_SET.has(word[i])) {
      consecutiveCount++;
      if (consecutiveCount > maxConsecutive) return true;
    } else {
      consecutiveCount = 0;
    }
  }
  return false;
}

// Меняем имя для ясности и добавляем параметр максимума
function hasConsecutiveConsonants(word: string, maxConsecutive: number): boolean {
  let consecutiveCount = 0;
  for (let i = 0; i < word.length; i++) {
    if (CONSONANTS_SET.has(word[i].toLowerCase())) { // Проверяем на всякий случай с toLowerCase
      consecutiveCount++;
      if (consecutiveCount > maxConsecutive) return true;
    } else {
      consecutiveCount = 0;
    }
  }
  return false;
}

// Обновляем ADVERB_RULES, чтобы он использовал новую функцию
const ADVERB_RULES = {
  // Начальные сочетания согласных
  initialConsonants: {
    // Шумный + сонорный
    obstruentSonorant: ['пр', 'бр', 'тр', 'др', 'кр', 'гр', 'вр', 'пл', 'бл', 'кл', 'гл', 'фл'],
    // Шумный + шумный
    obstruentObstruent: ['ст', 'ск', 'сп', 'зд', 'шт', 'жд'],
    // в + согласный
    vClusters: ['вз', 'вс', 'вн'],
    // Одиночные согласные (исключаем ц и щ)
    single: 'бвгджзклмнпрстфхчшщ'.split('')
  },
  
  // Суффиксы для наречий с их весами
  suffixes: [
    { value: 'тельн', weight: 0.2 },
    { value: 'ичн', weight: 0.2 },
    { value: 'альн', weight: 0.2 },
    { value: 'озн', weight: 0.15 },
    { value: 'ивн', weight: 0.15 },
    { value: '', weight: 0.1 } // Для случаев как "красиво"
  ],
  
  // Гласные после шипящих
  vowelsAfterHushing: ['а', 'о', 'у', 'е', 'и'],
  
  // Гласные после ц - удаляем, так как ц исключена
  
  // Используем общий список гласных
  regularVowels: Array.from(VOWELS_SET),
  
  hasConsecutiveVowels,
  hasConsecutiveConsonants: (word: string) => hasConsecutiveConsonants(word, 3)
};

// Выбор элемента с учетом весов
function weightedChoice<T extends { weight: number }>(items: T[]): T {
  if (!items.length) return items[0];
  
  const totalWeight = items.reduce((sum, item) => sum + item.weight, 0);
  let random = Math.random() * totalWeight;
  
  for (const item of items) {
    random -= item.weight;
    if (random <= 0) return item;
  }
  
  return items[0];
}

// Генерация основы слова
function generateStem(): string {
  const consonants = ADVERB_RULES.initialConsonants.single;
  const vowels = ADVERB_RULES.regularVowels;
  
  // Создаем основу CVCVCV или CCVCVCV
  const useCluster = Math.random() < 0.4; // Увеличили вероятность кластера
  let stem = '';
  
  if (useCluster) {
    const clusters = [
      ...ADVERB_RULES.initialConsonants.obstruentSonorant,
      ...ADVERB_RULES.initialConsonants.obstruentObstruent,
      ...ADVERB_RULES.initialConsonants.vClusters
    ];
    stem = clusters[Math.floor(Math.random() * clusters.length)];
  } else {
    stem = consonants[Math.floor(Math.random() * consonants.length)];
  }
  
  // Добавляем 2-3 слога CV
  const syllableCount = 2 + Math.floor(Math.random() * 2);
  for (let i = 0; i < syllableCount; i++) {
    // Добавляем гласный
    stem += vowels[Math.floor(Math.random() * vowels.length)];
    
    // Добавляем согласный (кроме последнего слога)
    if (i < syllableCount - 1) {
      stem += consonants[Math.floor(Math.random() * consonants.length)];
    }
  }
  
  return stem;
}

// Проверка на допустимость сочетаний согласных
function hasValidConsonantClusters(word: string): boolean {
  // Проверка на недопустимые сочетания в начале
  const initialCluster = word.match(/^[бвгджзклмнпрстфхцчшщ]+/)?.[0] || '';
  if (initialCluster.length > 2) return false;
  
  // Проверка на недопустимые сочетания внутри слова
  const consonantClusters = word.match(/[бвгджзклмнпрстфхцчшщ]{2,}/g) || [];
  return !consonantClusters.some(cluster => cluster.length > 3);
}

// НОВАЯ ФУНКЦИЯ: Мутация путем обмена букв между слогами
// Перемещена сюда, чтобы быть доступной для generateNonWord
function mutateBySwappingLetters(
  word: string, 
  forceConsonants: boolean = false, // Флаг для принудительного обмена согласных
  forceVowels: boolean = false, // Флаг для принудительного обмена гласных
  debug: boolean = false // Опциональный флаг для отладки
  ): string | null {
  const len = word.length;
  if (len < 5) return null; 

  const letters = word.split('');
  const indices = letters.map((_, idx) => idx);

  const inner_indices = indices.slice(1, -1);
  const vowel_indices_all_inner = inner_indices.filter(idx => VOWELS_SET.has(letters[idx].toLowerCase()));
  const consonant_indices_all_inner = inner_indices.filter(idx => CONSONANTS_SET.has(letters[idx].toLowerCase()));

  let vowel_indices = vowel_indices_all_inner;
  let consonant_indices = consonant_indices_all_inner;

  // Защита окончаний -но/-во
  if (word.endsWith('но') || word.endsWith('во')) {
      const protected_index = len - 2;
      if (protected_index > 0) { // Убедимся, что индекс валидный
          vowel_indices = vowel_indices_all_inner.filter(idx => idx !== protected_index);
          consonant_indices = consonant_indices_all_inner.filter(idx => idx !== protected_index);
          // if (debug) console.log(`    [Swap Protect TS] Protecting index ${protected_index} in ${word}`);
      }
  }

  const attempts = 10;
  for (let i = 0; i < attempts; i++) {
    const can_swap_vowels = vowel_indices.length >= 2;
    const can_swap_consonants = consonant_indices.length >= 2;

    let indices_to_swap_pool: number[] | null = null;
    let type_swapped: 'vowel' | 'consonant' | null = null;

    // Логика выбора типа обмена
    if (forceConsonants) {
        if (can_swap_consonants) {
            indices_to_swap_pool = consonant_indices;
            type_swapped = 'consonant';
        } else continue;
    } else if (forceVowels) {
        if (can_swap_vowels) {
            indices_to_swap_pool = vowel_indices;
            type_swapped = 'vowel';
        } else continue;
    } else if (can_swap_vowels && can_swap_consonants) {
        if (Math.random() < 0.5) {
            indices_to_swap_pool = vowel_indices;
            type_swapped = 'vowel';
    } else {
            indices_to_swap_pool = consonant_indices;
            type_swapped = 'consonant';
        }
    } else if (can_swap_consonants) {
        indices_to_swap_pool = consonant_indices;
        type_swapped = 'consonant';
    } else if (can_swap_vowels) {
        indices_to_swap_pool = vowel_indices;
        type_swapped = 'vowel';
    } else {
        continue;
    }

    if (!indices_to_swap_pool) continue; 

    let idx1 = getRandomElement(indices_to_swap_pool);
    const pool_without_idx1 = indices_to_swap_pool.filter(idx => idx !== idx1);
    if (pool_without_idx1.length === 0) continue; 
    let idx2 = getRandomElement(pool_without_idx1);

    // Проверка на гласную между для СОГЛАСНЫХ
    if (type_swapped === 'consonant') {
        const [startIdx, endIdx] = [Math.min(idx1, idx2), Math.max(idx1, idx2)];
        let vowelBetween = false;
        for (let k = startIdx + 1; k < endIdx; k++) {
            if (VOWELS_SET.has(letters[k].toLowerCase())) {
                vowelBetween = true;
                break;
            }
        }
        if (!vowelBetween) continue; 
    }

    const mutated_list = [...letters]; // Создаем копию
    [mutated_list[idx1], mutated_list[idx2]] = [mutated_list[idx2], mutated_list[idx1]];
    const mutated = mutated_list.join('');

    // Проверки
    if (mutated !== word &&
        !REAL_WORDS_SET.has(mutated.toLowerCase()) &&
        isPhonotacticallyPlausible(mutated)) {
      // if (debug) console.log(`    [Swap OK TS ({type_swapped})] ${word} -> ${mutated}`);
      return mutated;
    }
  }
  // if (debug) {
  //     const swap_type_str = forceConsonants ? "consonants" : forceVowels ? "vowels" : "letters";
  //     console.log(`    [Swap Fail TS] Could not mutate ${word} by swapping ${swap_type_str}`);
  // }
  return null; // Не удалось сделать удачную мутацию обменом
}

// Функция простой мутации слова (v2: без первой/последней буквы)
// Перемещаем ее сюда, чтобы она была доступна generateNonWord
function mutateByReplacingLetter(word: string, realWordsSet: Set<string>, debug: boolean = false): string | null {
  const len = word.length;
  if (len < 4) return null; 

  const attempts = 10; 
  
  for (let i = 0; i < attempts; i++) {
    let indexToMutate = 1 + Math.floor(Math.random() * (len - 2)); 

    const originalChar = word[indexToMutate];
    let replacementChar = '';

    if (VOWELS_SET.has(originalChar.toLowerCase())) {
      const possibleReplacements = VOWELS_RU.split('').filter(l => l !== originalChar.toLowerCase());
      if(possibleReplacements.length === 0) continue;
      replacementChar = getRandomElement(possibleReplacements);
    } else if (CONSONANTS_SET.has(originalChar.toLowerCase())) {
       const possibleReplacements = CONSONANTS_RU.split('').filter(l => l !== originalChar.toLowerCase());
       if(possibleReplacements.length === 0) continue;
       replacementChar = getRandomElement(possibleReplacements);
  } else {
      continue; 
    }

    if (originalChar === originalChar.toUpperCase()) {
      replacementChar = replacementChar.toUpperCase();
    }

    const mutated = word.substring(0, indexToMutate) + replacementChar + word.substring(indexToMutate + 1);

    if (mutated !== word && 
        !realWordsSet.has(mutated.toLowerCase()) && 
        isPhonotacticallyPlausible(mutated)) {
       // if (debug) console.log(`    [Replace OK TS] ${word} -> ${mutated}`);
      return mutated; 
    }
  }
  // if (debug) console.log(`    [Replace Fail TS] Could not mutate ${word} by replacing`);
  return null; 
}

// Генератор не-слов (v6: Комбинированный, Случайный порядок обменов, Приоритет Внешнего Списка)
const generateNonWord = (baseWordForMutation: string): string => {
    const maxAttemptsPerExternalWord = 5;
    const debug = false;

    if (debug) console.log(`\nGenerating non-word (target was: '${baseWordForMutation}')`);

    if (EXTERNAL_SIMILAR_ADVERBS.length === 0) {
        console.warn("EXTERNAL_SIMILAR_ADVERBS is empty! Logic will fallback to target word mutation.");
    }

    const shuffledExternalAdverbs = shuffle([...EXTERNAL_SIMILAR_ADVERBS]);

    // --- Попытки с ВНЕШНИМИ словами --- 
    for (let attempt = 0; attempt < maxAttemptsPerExternalWord; attempt++) {
        const externalBaseWord = shuffledExternalAdverbs[attempt % shuffledExternalAdverbs.length];
        if (!externalBaseWord) continue;

        if (debug) console.log(`  Attempt ${attempt + 1}: Using external base '${externalBaseWord}'...`);

        let nonWord: string | null = null;
        const tryVowelSwapFirst = Math.random() < 0.5;

        if (tryVowelSwapFirst) {
            // 1a. Обмен ГЛАСНЫХ (внешнее)
            nonWord = mutateBySwappingLetters(externalBaseWord, false, true, debug);
            if (nonWord) {
                if (debug) console.log(`    Success (Ext): Vowel Swap (1st try) -> ${nonWord}`);
                return nonWord;
            }
            // 1b. Обмен СОГЛАСНЫХ (внешнее, если гласные не сработали)
            nonWord = mutateBySwappingLetters(externalBaseWord, true, false, debug);
            if (nonWord) {
                 if (debug) console.log(`    Success (Ext): Consonant Swap (2nd try) -> ${nonWord}`);
                return nonWord;
            }
        } else {
            // 1a. Обмен СОГЛАСНЫХ (внешнее)
            nonWord = mutateBySwappingLetters(externalBaseWord, true, false, debug);
            if (nonWord) {
                 if (debug) console.log(`    Success (Ext): Consonant Swap (1st try) -> ${nonWord}`);
                return nonWord;
            }
            // 1b. Обмен ГЛАСНЫХ (внешнее, если согласные не сработали)
            nonWord = mutateBySwappingLetters(externalBaseWord, false, true, debug);
            if (nonWord) {
                if (debug) console.log(`    Success (Ext): Vowel Swap (2nd try) -> ${nonWord}`);
                return nonWord;
            }
        }

        // 2. Замена ВНУТРЕННЕЙ БУКВЫ (внешнее, если оба обмена не сработали)
        nonWord = mutateByReplacingLetter(externalBaseWord, REAL_WORDS_SET, debug);
        if (nonWord) {
          if (debug) console.log(`    Success (Ext): Replace Letter (3rd try) -> ${nonWord}`);
          return nonWord;
        }
        
        if (debug) console.log(`    Failed all mutations for external base '${externalBaseWord}'.`);
    }

    // --- Fallback: Если с внешними словами ничего не вышло --- 
    console.warn('All attempts with external words failed. Falling back to target word mutations...');
    
    let fallbackResult: string | null = null;
    const tryVowelSwapFirstFallback = Math.random() < 0.5;

    if (tryVowelSwapFirstFallback) {
        // 3a. Обмен ГЛАСНЫХ (целевое)
        fallbackResult = mutateBySwappingLetters(baseWordForMutation, false, true, debug);
        if (fallbackResult) {
            if (debug) console.log(`    Fallback Success: Vowel Swap on TARGET (1st try) -> ${fallbackResult}`);
            return fallbackResult;
        }
        // 3b. Обмен СОГЛАСНЫХ (целевое)
        fallbackResult = mutateBySwappingLetters(baseWordForMutation, true, false, debug);
        if (fallbackResult) {
            if (debug) console.log(`    Fallback Success: Consonant Swap on TARGET (2nd try) -> ${fallbackResult}`);
            return fallbackResult;
        }
    } else {
         // 3a. Обмен СОГЛАСНЫХ (целевое)
         fallbackResult = mutateBySwappingLetters(baseWordForMutation, true, false, debug);
         if (fallbackResult) {
             if (debug) console.log(`    Fallback Success: Consonant Swap on TARGET (1st try) -> ${fallbackResult}`);
             return fallbackResult;
         }
          // 3b. Обмен ГЛАСНЫХ (целевое)
         fallbackResult = mutateBySwappingLetters(baseWordForMutation, false, true, debug);
         if (fallbackResult) {
             if (debug) console.log(`    Fallback Success: Vowel Swap on TARGET (2nd try) -> ${fallbackResult}`);
             return fallbackResult;
         }
    }

    // 4. Замена ВНУТРЕННЕЙ БУКВЫ (целевое, если оба обмена не сработали)
    fallbackResult = mutateByReplacingLetter(baseWordForMutation, REAL_WORDS_SET, debug);
    if (fallbackResult) {
        if (debug) console.log(`    Fallback Success: Replace Letter on TARGET (3rd try) -> ${fallbackResult}`);
        return fallbackResult;
    }

    // 5. Абсолютно крайний случай (v5): Берем ЕЩЕ ОДНО внешнее слово и применяем старый fallback
    console.error('All mutation strategies failed! Applying final fallback modification to ANOTHER external word.');
    let finalBase = baseWordForMutation; 
    if (EXTERNAL_SIMILAR_ADVERBS.length > 0) {
        const potentialBases = EXTERNAL_SIMILAR_ADVERBS.filter(w => w !== baseWordForMutation);
        finalBase = getRandomElement(potentialBases.length > 0 ? potentialBases : EXTERNAL_SIMILAR_ADVERBS);
    }
    if (debug) console.log(`    Final fallback using base: '${finalBase}'`);
    
    const len = finalBase.length;
    const endsWithAdverbSuffix = finalBase.endsWith('но') || finalBase.endsWith('во');
    let fallbackWord = finalBase;

    // Логика изменения 3-й с конца или последней буквы
    if (len >= 4 && endsWithAdverbSuffix) {
        const indexToChange = len - 3;
        const originalFallbackChar = finalBase[indexToChange].toLowerCase();
        const possibleReplacements = ALL_LETTERS_RU.split('').filter(l => l !== originalFallbackChar);
        if (possibleReplacements.length > 0) {
            const replacement = getRandomElement(possibleReplacements);
            fallbackWord = finalBase.substring(0, indexToChange) + replacement + finalBase.substring(indexToChange + 1);
        } 
        // Если замен нет (маловероятно), fallbackWord останется = finalBase
    } else if (len >= 2) {
        const lastChar = finalBase.slice(-1);
        const possibleReplacements = ALL_LETTERS_RU.split('').filter(l => l !== lastChar);
        if (possibleReplacements.length > 0) {
            fallbackWord = finalBase.slice(0, -1) + getRandomElement(possibleReplacements); 
        } else { 
             fallbackWord = finalBase.slice(0, -1) + lastChar;
        }
    }
    
    // Последняя проверка
    if (REAL_WORDS_SET.has(fallbackWord.toLowerCase()) || !isPhonotacticallyPlausible(fallbackWord)) {
        console.warn(`Final fallback created a bad word (${fallbackWord}), returning simple base modification of the ORIGINAL target.`);
        const lastCharOrig = baseWordForMutation.slice(-1);
        const possibleReplacementsOrig = ALL_LETTERS_RU.split('').filter(l => l !== lastCharOrig);
        if (baseWordForMutation.length >= 2 && possibleReplacementsOrig.length > 0) {
            return baseWordForMutation.slice(0, -1) + getRandomElement(possibleReplacementsOrig);
        } else {
            return baseWordForMutation.charAt(0) + 'о'; 
        }
    }

    if (debug) console.log(`    Final fallback result: ${fallbackWord}`);
    return fallbackWord;
};

/**
 * Создает испытания для одного изображения (v2)
 */
function createTrialsForImage(image: ImageData): Trial[] {
  // Уменьшаем количество испытаний до 2 (1 реальное слово + 1 не-слово)
  const NUM_REAL_WORDS_PER_IMAGE = 1;
  const NUM_NON_WORDS_PER_IMAGE = 1;
  
  const trials: Trial[] = [];
  const usedNonWords = new Set<string>();

  // 1. Выборка реальных слов
  const shuffledAestheticWords = shuffle([...AESTHETIC_WORDS]); // Копируем и перемешиваем
  const selectedRealWords = shuffledAestheticWords.slice(0, NUM_REAL_WORDS_PER_IMAGE);

  // 2. Генерация не-слов
  const nonWords: string[] = [];
  let attempts = 0;
  while (nonWords.length < NUM_NON_WORDS_PER_IMAGE && attempts < 50) { // Ограничение попыток
    // Берем случайное реальное слово как базу для генерации
    const baseWord = selectedRealWords[nonWords.length % selectedRealWords.length].word; 
    const nonWord = generateNonWord(baseWord);
    
    // Проверяем уникальность среди уже сгенерированных не-слов и реальных слов
    if (!usedNonWords.has(nonWord) && !selectedRealWords.some(rw => rw.word === nonWord)) {
      usedNonWords.add(nonWord);
      nonWords.push(nonWord);
    }
    attempts++;
  }
  
  if (nonWords.length < NUM_NON_WORDS_PER_IMAGE) {
    console.warn(`Could not generate enough unique non-words for image ${image.fileName}`);
  }

  // 3. Создание испытаний
  selectedRealWords.forEach(realWord => {
    trials.push({
      imageId: image.id,
      imageFileName: image.fileName,
      word: realWord.word,
      wordType: 'aesthetic'
    });
  });

  nonWords.forEach(nonWord => {
      trials.push({
        imageId: image.id,
      imageFileName: image.fileName,
        word: nonWord,
        wordType: 'non-word'
      });
  });

  // Перемешиваем испытания для данного изображения
  return shuffle(trials);
}

// Функция для предварительной загрузки только нужных изображений
async function preloadImages(imageUrls: string[]): Promise<void> {
  console.log(`Preloading ${imageUrls.length} images for current session...`);
  let loadedCount = 0;
  
  try {
    await Promise.all(imageUrls.map(url => {
      return new Promise<void>((resolve, reject) => {
        const img = new Image();
        img.onload = () => {
          loadedCount++;
          // Логируем прогресс каждые 10 изображений
          if (loadedCount % 10 === 0) {
            console.log(`Preloaded ${loadedCount}/${imageUrls.length} images`);
          }
          resolve();
        };
        img.onerror = () => {
          console.warn(`Failed to preload image: ${url}`);
          resolve(); // Резолвим даже при ошибке, чтобы не блокировать весь процесс
        };
        // Добавляем временную метку для предотвращения кеширования
        const timestamp = new Date().getTime();
        img.src = `${url}?t=${timestamp}`;
      });
    }));
    
    console.log(`Successfully preloaded ${loadedCount}/${imageUrls.length} images for the session`);
  } catch (error) {
    console.error('Error during image preloading:', error);
  }
}

// Увеличиваем количество изображений в сессии для ещё большего разнообразия
const NUM_IMAGES_PER_SESSION = 40; // Было 30, теперь 40

// --- Начало изменений Шага 3 --- 
// Глобальная статистика слов (кешируется)
let wordStatsCache: { [word: string]: number } | null = null;

// Функция загрузки глобальной статистики слов
export async function loadWordStats(): Promise<{ [word: string]: number }> {
  if (wordStatsCache) {
    console.log('Returning cached word stats.');
    return wordStatsCache;
  }
  try {
    console.log('Loading global word stats...');
    const statsSnapshot = await getDocs(collection(db, 'wordStats'));
    const stats: { [word: string]: number } = {};
    statsSnapshot.forEach(doc => {
      const data = doc.data();
      if (data.word && typeof data.totalShownCount === 'number') {
        stats[data.word] = data.totalShownCount;
      } else {
         console.warn('Skipping invalid wordStat document:', doc.id, data);
      }
    });
    wordStatsCache = stats;
    console.log(`Loaded ${Object.keys(stats).length} word stats.`);
    return stats;
  } catch (error) {
    console.error('Error loading word stats:', error);
    return {}; // Возвращаем пустой объект при ошибке
  }
}
// --- Конец изменений Шага 3 --- 

export async function createSession(
  participantId: string,
  completedImageFileNames: string[],
  imagesSeenWithRealWordNames: string[],
  previousTrials: { imageFileName: string, word: string, wordType: string }[] = [],
  isTestSession: boolean,
  // Добавляем счетчики моделей как параметр
  v8SeenCount: number = 0,
  v10SeenCount: number = 0
): Promise<Session> {
  
  await loadImages();
  await loadWordStats(); // Предзагружаем статистику слов
  if (IMAGES.length === 0) {
      throw new Error("Image data is not available after attempting to load.");
  }

  console.log("Total images available:", IMAGES.length);
  console.log("Previously completed images (any word):", completedImageFileNames.length);
  console.log("Images seen with a REAL word:", imagesSeenWithRealWordNames.length);
  console.log("Previous trials count:", previousTrials.length);

  // Загружаем глобальную статистику изображений
  const globalImageStats = await getGlobalImageStats();
  console.log("Loaded global image stats for", Object.keys(globalImageStats).length, "images");

  const usedImageWordPairs = new Set<string>();
  previousTrials.forEach(trial => {
    usedImageWordPairs.add(`${trial.imageFileName}|${trial.word}|${trial.wordType}`);
  });

  // --- Измененная логика выбора картинок ---
  
  // 1. Разделение ВСЕХ картинок на три группы
  const unseenImages = IMAGES.filter(img => !completedImageFileNames.includes(img.fileName));
  const seenButNotWithReal = IMAGES.filter(img => 
    completedImageFileNames.includes(img.fileName) && 
    !imagesSeenWithRealWordNames.includes(img.fileName)
  );
  const seenWithReal = IMAGES.filter(img => imagesSeenWithRealWordNames.includes(img.fileName));

  console.log(`Image groups: Unseen=${unseenImages.length}, SeenWithoutReal=${seenButNotWithReal.length}, SeenWithReal=${seenWithReal.length}`);

  // Функция для получения глобального количества показов изображения
  const getGlobalImageShowCount = (fileName: string): number => globalImageStats[fileName] || 0;

  let selectedImagesForSession: ImageData[] = [];
  
  // 2. Приоритет 1: Абсолютно новые (unseenImages)
  if (unseenImages.length > 0) {
    // Сортируем по глобальному счетчику показов (сначала наименее показанные)
    unseenImages.sort((a, b) => {
      // Сначала сортируем по глобальному количеству показов
      const globalCountA = getGlobalImageShowCount(a.fileName);
      const globalCountB = getGlobalImageShowCount(b.fileName);
      if (globalCountA !== globalCountB) {
        return globalCountA - globalCountB; // Сначала изображения с меньшим количеством показов
      }

      // Если глобальные счетчики равны, учитываем модель
      const modelDict = modelDictionaryCache || {};
      const modelA = modelDict[a.fileName];
      const modelB = modelDict[b.fileName];
      
      // Отдаем приоритет модели, которую видели реже
      if (modelA === 'v8_latent_finetune' && modelB !== 'v8_latent_finetune') {
        return v8SeenCount - v10SeenCount; // Если v8 видели реже, он будет раньше
      } else if (modelA !== 'v8_latent_finetune' && modelB === 'v8_latent_finetune') {
        return v10SeenCount - v8SeenCount; // Если v10 видели реже, он будет раньше
      }
      
      return Math.random() - 0.5; // Если все счетчики равны, перемешиваем случайно
    });
    
    const numToTake = Math.min(unseenImages.length, NUM_IMAGES_PER_SESSION);
    selectedImagesForSession.push(...unseenImages.slice(0, numToTake));
    console.log(`Selected ${selectedImagesForSession.length} from UNSEEN group (globally balanced).`);
  }

  // 3. Приоритет 2: Виденные, но НЕ с реальным словом (seenButNotWithReal)
  if (selectedImagesForSession.length < NUM_IMAGES_PER_SESSION && seenButNotWithReal.length > 0) {
    const numNeeded = NUM_IMAGES_PER_SESSION - selectedImagesForSession.length;
    
    // Сортируем по тем же критериям, что и unseenImages
    seenButNotWithReal.sort((a, b) => {
      // Сначала сортируем по глобальному количеству показов
      const globalCountA = getGlobalImageShowCount(a.fileName);
      const globalCountB = getGlobalImageShowCount(b.fileName);
      if (globalCountA !== globalCountB) {
        return globalCountA - globalCountB;
      }

      // Затем учитываем модель
      const modelDict = modelDictionaryCache || {};
      const modelA = modelDict[a.fileName];
      const modelB = modelDict[b.fileName];
      if (modelA === 'v8_latent_finetune' && modelB !== 'v8_latent_finetune') return v8SeenCount - v10SeenCount;
      if (modelA !== 'v8_latent_finetune' && modelB === 'v8_latent_finetune') return v10SeenCount - v8SeenCount;
      return Math.random() - 0.5;
    });
    
    const numToTake = Math.min(seenButNotWithReal.length, numNeeded);
    selectedImagesForSession.push(...seenButNotWithReal.slice(0, numToTake));
    console.log(`Selected ${numToTake} from SEEN_WITHOUT_REAL group (globally balanced).`);
  }

  // 4. Приоритет 3: Уже виденные с реальным словом (seenWithReal)
  if (selectedImagesForSession.length < NUM_IMAGES_PER_SESSION && seenWithReal.length > 0) {
    const numNeeded = NUM_IMAGES_PER_SESSION - selectedImagesForSession.length;
    
    // Учитываем разнообразие слов для картинок с реальными словами
    const imageRealWordCount = new Map<string, number>();
    seenWithReal.forEach(img => {
      const count = new Set(previousTrials
        .filter(trial => trial.imageFileName === img.fileName && trial.wordType === 'aesthetic')
        .map(t => t.word)
      ).size;
      imageRealWordCount.set(img.fileName, count);
    });
    
    seenWithReal.sort((a, b) => {
      // Приоритет 1: Глобальное количество показов
      const globalCountA = getGlobalImageShowCount(a.fileName);
      const globalCountB = getGlobalImageShowCount(b.fileName);
      if (globalCountA !== globalCountB) {
        return globalCountA - globalCountB;
      }
      
      // Приоритет 2: Модель, которую видели реже
      const modelDict = modelDictionaryCache || {};
      const modelA = modelDict[a.fileName];
      const modelB = modelDict[b.fileName];
      let modelCompare = 0;
      if (modelA === 'v8_latent_finetune' && modelB !== 'v8_latent_finetune') modelCompare = v8SeenCount - v10SeenCount;
      else if (modelA !== 'v8_latent_finetune' && modelB === 'v8_latent_finetune') modelCompare = v10SeenCount - v8SeenCount;
      
      if (modelCompare !== 0) return modelCompare;
      
      // Приоритет 3: Картинка с меньшим разнообразием реальных слов
      return (imageRealWordCount.get(a.fileName) || 0) - (imageRealWordCount.get(b.fileName) || 0);
    });
    
    const numToTake = Math.min(seenWithReal.length, numNeeded);
    selectedImagesForSession.push(...seenWithReal.slice(0, numToTake));
    console.log(`Selected ${numToTake} from SEEN_WITH_REAL group (globally balanced).`);
  }
  // --- Конец измененной логики выбора картинок ---

  // Удаляем дубликаты на всякий случай и обрезаем до 40
  selectedImagesForSession = Array.from(
    new Map(selectedImagesForSession.map(img => [img.fileName, img])).values()
  ).slice(0, NUM_IMAGES_PER_SESSION);
  
  console.log("Final selection contains:", selectedImagesForSession.length, "unique images");

  // Предварительная загрузка ТОЛЬКО выбранных изображений
  const imageUrls = selectedImagesForSession.map(img => img.url);
  try {
  await preloadImages(imageUrls);
    console.log('Selected images preloaded for current session.');
  } catch (error) {
    console.error('Error preloading session images:', error);
  }

  // НОВОЕ: Отслеживаем слова, использованные в текущей сессии
  const sessionUsedWords = new Set<string>();
  const sessionUsedNonWords = new Set<string>();

  // --- Начало изменений для Шага 2 --- 
  // Счетчики для контроля баланса 70/30 в сессии
  let realWordsInSessionCount = 0;
  let nonWordsInSessionCount = 0;
  
  // Функция для обновления счетчиков, которую будем передавать
  const updateCounts = (wordType: WordType) => {
    if (wordType === 'aesthetic') {
      realWordsInSessionCount++;
    } else {
      nonWordsInSessionCount++;
    }
  };
  // --- Конец изменений для Шага 2 --- 

  // Создаем испытания для каждого выбранного изображения
  const allTrialsForSession = [];
  const shuffledImages = shuffle([...selectedImagesForSession]);
  
  for (const image of shuffledImages) {
    // --- Начало изменений для Шага 2 --- 
    // Передаем счетчики и колбэк в функцию выбора слова
    const trial = createTrialsForImageWithHistory(
      image, 
      usedImageWordPairs,
      sessionUsedWords,
      sessionUsedNonWords,
      realWordsInSessionCount, // Передаем текущие счетчики
      nonWordsInSessionCount,
      updateCounts // Передаем колбэк для обновления
    )[0];
    // --- Конец изменений для Шага 2 --- 
    
    // Добавляем использованное слово в трекер для этой сессии
    if (trial.wordType === 'aesthetic') {
      sessionUsedWords.add(trial.word);
    } else {
      sessionUsedNonWords.add(trial.word);
    }
    
    allTrialsForSession.push(trial);
  }
  
  // Перемешиваем все испытания
  const shuffledTrials = shuffle(allTrialsForSession);
  
  console.log(`Created session with ${shuffledTrials.length} trials using unique words.`);
  console.log(`Used ${sessionUsedWords.size} unique real words and ${sessionUsedNonWords.size} unique non-words.`);

  return {
    sessionId: Math.random().toString(36).substring(7),
    participantId,
    trials: shuffledTrials,
    currentTrialIndex: 0,
    completedTrials: 0,
    totalTrials: shuffledTrials.length,
  } as Session;
}

/**
 * Создает испытание для изображения с учетом истории показов и уже использованных слов в текущей сессии
 */
function createTrialsForImageWithHistory(
  image: ImageData,
  usedImageWordPairs: Set<string>,
  sessionUsedWords: Set<string> = new Set(),
  sessionUsedNonWords: Set<string> = new Set(),
  // Новые параметры для Шага 2
  currentRealCount: number,
  currentNonWordCount: number,
  updateCountsCallback: (wordType: WordType) => void
): Trial[] {
  // Определяем историю показов для этой картинки
  const usedWords = new Set<string>();
  let hasBeenShownWithRealWord = false;
  Array.from(usedImageWordPairs).forEach(pair => {
    if (pair.startsWith(`${image.fileName}|`)) {
      const [_, word, wordType] = pair.split('|');
      usedWords.add(word);
      if (wordType === 'aesthetic') {
        hasBeenShownWithRealWord = true;
      }
    }
  });

  // --- Начало новой логики выбора типа слова (Шаг 2) ---
  const targetRealRatio = 0.625; // Цель: 62.5% реальных слов (соответствует 37.5% не-слов, т.е. 15 из 40)
  const totalSoFar = currentRealCount + currentNonWordCount;
  let adjustedRealWordChance = targetRealRatio; // Начинаем с базового шанса

  if (totalSoFar > 0) { // Избегаем деления на ноль и корректируем только после нескольких выборов
    const currentRealRatio = currentRealCount / totalSoFar;
    // Простая линейная коррекция (можно сделать сложнее)
    if (currentRealRatio < targetRealRatio - 0.05) { // Если реальных слов СЛИШКОМ МАЛО
      adjustedRealWordChance = targetRealRatio + 0.1; // Повышаем шанс до 80%
    } else if (currentRealRatio > targetRealRatio + 0.05) { // Если реальных слов СЛИШКОМ МНОГО
      adjustedRealWordChance = targetRealRatio - 0.1; // Понижаем шанс до 60%
    }
  }
  // Ограничиваем шанс разумными пределами (например, 0.5 до 0.9)
  adjustedRealWordChance = Math.max(0.5, Math.min(0.9, adjustedRealWordChance)); 

  const shouldBeRealWord = Math.random() < adjustedRealWordChance;

  console.log(
    `Image: ${image.fileName}, Counts(R/N): ${currentRealCount}/${currentNonWordCount}, ` +
    `CurrentRatio: ${(totalSoFar > 0 ? (currentRealCount / totalSoFar) : 0).toFixed(2)}, ` +
    `AdjustedChance: ${adjustedRealWordChance.toFixed(2)}, Decision: ${shouldBeRealWord ? 'REAL' : 'NON-WORD'}`
  );
  // --- Конец новой логики выбора типа слова (Шаг 2) ---

  let selectedWord: string | null = null;
  let selectedWordType: WordType | null = null;

  if (shouldBeRealWord) {
    // --- Начало изменений Шага 3 --- 
    // Получаем глобальную статистику (из кеша)
    const globalWordStats = wordStatsCache || {};
    
    // Функция для получения счетчика слова (0, если нет)
    const getWordCount = (word: string) => globalWordStats[word] || 0;
    // --- Конец изменений Шага 3 --- 

    // Попытка 1: Новое для картинки и сессии, СОРТИРОВКА по глобальному счетчику
    let availableWords = AESTHETIC_WORDS.filter(
      word => !usedWords.has(word.word) && !sessionUsedWords.has(word.word)
    );
    if (availableWords.length > 0) {
      // Сортируем по возрастанию глобального счетчика
      availableWords.sort((a, b) => getWordCount(a.word) - getWordCount(b.word));
      selectedWord = availableWords[0].word; // Берем самое редкое
      selectedWordType = 'aesthetic';
      console.log(` -> Chose NEW aesthetic word (globally rarest): ${selectedWord} (count: ${getWordCount(selectedWord)})`);
    }

    // Попытка 2: Новое для сессии, СОРТИРОВКА по глобальному счетчику
    if (!selectedWord) {
      availableWords = AESTHETIC_WORDS.filter(
        word => !sessionUsedWords.has(word.word)
      );
      if (availableWords.length > 0) {
        availableWords.sort((a, b) => getWordCount(a.word) - getWordCount(b.word));
        selectedWord = availableWords[0].word;
        selectedWordType = 'aesthetic';
        console.log(` -> Chose SESSION-UNUSED aesthetic word (globally rarest): ${selectedWord} (count: ${getWordCount(selectedWord)})`);
      }
    }
    
    // Попытка 3: Любое слово, СОРТИРОВКА по глобальному счетчику
    if (!selectedWord && AESTHETIC_WORDS.length > 0) {
        availableWords = [...AESTHETIC_WORDS]; // Берем все слова
        availableWords.sort((a, b) => getWordCount(a.word) - getWordCount(b.word));
        selectedWord = availableWords[0].word;
        selectedWordType = 'aesthetic';
        console.log(` -> Chose ANY available aesthetic word (globally rarest): ${selectedWord} (count: ${getWordCount(selectedWord)})`);
    }
  }

  // Если должно быть не-слово ИЛИ не удалось найти подходящее настоящее слово
  if (!shouldBeRealWord || !selectedWord) {
    console.log(` -> Generating NON-WORD (Reason: ${!shouldBeRealWord ? 'Decision' : 'Fallback'})`);
    let nonWord: string;
    let attempts = 0;
    do {
      const baseWord = shuffle(AESTHETIC_WORDS)[0].word;
      nonWord = generateNonWord(baseWord);
      attempts++;
      if (attempts > 20) {
        console.warn('Could not generate unique non-word after 20 attempts, using potentially non-unique.');
        break;
      }
    } while (sessionUsedNonWords.has(nonWord) || sessionUsedWords.has(nonWord));
    
    selectedWord = nonWord;
    selectedWordType = 'non-word';
  }

  // Убедимся, что слово выбрано
  if (!selectedWord || !selectedWordType) {
    console.error('Error: Failed to select a word for trial!', { image, selectedWord, selectedWordType });
    // Возвращаем заглушку, чтобы избежать падения
    return [{
        imageId: image.id,
        imageFileName: image.fileName,
        word: 'ОШИБКА',
        wordType: 'non-word' 
    }];
  }

  // ВАЖНО: Вызвать колбэк перед возвратом результата!
  if (selectedWordType) { 
    updateCountsCallback(selectedWordType);
  } else {
    // Если была ошибка и слово не выбрано (крайне маловероятно)
    // Засчитываем как не-слово, чтобы счетчики не разъезжались
    updateCountsCallback('non-word'); 
  }

  // Возвращаем результат
  return [{
    imageId: image.id,
    imageFileName: image.fileName,
    word: selectedWord,
    wordType: selectedWordType
  }];
}

// ... rest of the code ... 